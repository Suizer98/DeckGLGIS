/* tslint:disable */
/* eslint-disable */
/**
 * Volume API
 * API documentation
 *
 * The version of the OpenAPI document: v1
 * Contact: contact@volumeapi.local
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface DEMFile
 */
export interface DEMFile {
    /**
     * 
     * @type {number}
     * @memberof DEMFile
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DEMFile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DEMFile
     */
    'file'?: string;
    /**
     * 
     * @type {string}
     * @memberof DEMFile
     */
    'tile_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof DEMFile
     */
    'geoserver_url'?: string;
}
/**
 * 
 * @export
 * @interface GLBMesh
 */
export interface GLBMesh {
    /**
     * 
     * @type {number}
     * @memberof GLBMesh
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GLBMesh
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GLBMesh
     */
    'file'?: string;
    /**
     * 
     * @type {string}
     * @memberof GLBMesh
     */
    'file_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof GLBMesh
     */
    'data'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GLBMesh
     */
    'data_url'?: string;
}
/**
 * 
 * @export
 * @interface GeoTIFFFile
 */
export interface GeoTIFFFile {
    /**
     * 
     * @type {number}
     * @memberof GeoTIFFFile
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof GeoTIFFFile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GeoTIFFFile
     */
    'file'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeoTIFFFile
     */
    'tile_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof GeoTIFFFile
     */
    'geoserver_url'?: string;
}
/**
 * 
 * @export
 * @interface OBJMesh
 */
export interface OBJMesh {
    /**
     * 
     * @type {number}
     * @memberof OBJMesh
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OBJMesh
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OBJMesh
     */
    'file'?: string;
    /**
     * 
     * @type {string}
     * @memberof OBJMesh
     */
    'file_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof OBJMesh
     */
    'data'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OBJMesh
     */
    'data_url'?: string;
}
/**
 * 
 * @export
 * @interface PLYMesh
 */
export interface PLYMesh {
    /**
     * 
     * @type {number}
     * @memberof PLYMesh
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PLYMesh
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PLYMesh
     */
    'file'?: string;
    /**
     * 
     * @type {string}
     * @memberof PLYMesh
     */
    'file_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PLYMesh
     */
    'data'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PLYMesh
     */
    'data_url'?: string;
}
/**
 * 
 * @export
 * @interface PointCloudMesh
 */
export interface PointCloudMesh {
    /**
     * 
     * @type {number}
     * @memberof PointCloudMesh
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PointCloudMesh
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PointCloudMesh
     */
    'file'?: string;
    /**
     * 
     * @type {string}
     * @memberof PointCloudMesh
     */
    'file_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof PointCloudMesh
     */
    'data'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PointCloudMesh
     */
    'data_url'?: string;
}
/**
 * 
 * @export
 * @interface Polygon
 */
export interface Polygon {
    /**
     * 
     * @type {Array<Array<Array<number>>>}
     * @memberof Polygon
     */
    'polygons': Array<Array<Array<number>>>;
    /**
     * 
     * @type {number}
     * @memberof Polygon
     */
    'id'?: number;
}

/**
 * DemsApi - axios parameter creator
 * @export
 */
export const DemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DEMFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demsCreate: async (data: DEMFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('demsCreate', 'data', data)
            const localVarPath = `/dems/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dem file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demsDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('demsDelete', 'id', id)
            const localVarPath = `/dems/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dem file.
         * @param {string} z 
         * @param {string} x 
         * @param {string} y 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demsGetTile: async (id: number, z: string, x: string, y: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('demsGetTile', 'id', id)
            // verify required parameter 'z' is not null or undefined
            assertParamExists('demsGetTile', 'z', z)
            // verify required parameter 'x' is not null or undefined
            assertParamExists('demsGetTile', 'x', x)
            // verify required parameter 'y' is not null or undefined
            assertParamExists('demsGetTile', 'y', y)
            const localVarPath = `/dems/{id}/tiles/{z}/{x}/{y}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"z"}}`, encodeURIComponent(String(z)))
                .replace(`{${"x"}}`, encodeURIComponent(String(x)))
                .replace(`{${"y"}}`, encodeURIComponent(String(y)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dems/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dem file.
         * @param {DEMFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demsPartialUpdate: async (id: number, data: DEMFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('demsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('demsPartialUpdate', 'data', data)
            const localVarPath = `/dems/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dem file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demsRead: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('demsRead', 'id', id)
            const localVarPath = `/dems/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dem file.
         * @param {DEMFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demsUpdate: async (id: number, data: DEMFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('demsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('demsUpdate', 'data', data)
            const localVarPath = `/dems/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demsUploadDem: async (name: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('demsUploadDem', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('demsUploadDem', 'file', file)
            const localVarPath = `/dems/upload/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DemsApi - functional programming interface
 * @export
 */
export const DemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DemsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DEMFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async demsCreate(data: DEMFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DEMFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.demsCreate(data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DemsApi.demsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dem file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async demsDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.demsDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DemsApi.demsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dem file.
         * @param {string} z 
         * @param {string} x 
         * @param {string} y 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async demsGetTile(id: number, z: string, x: string, y: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DEMFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.demsGetTile(id, z, x, y, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DemsApi.demsGetTile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async demsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DEMFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.demsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DemsApi.demsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dem file.
         * @param {DEMFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async demsPartialUpdate(id: number, data: DEMFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DEMFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.demsPartialUpdate(id, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DemsApi.demsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dem file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async demsRead(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DEMFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.demsRead(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DemsApi.demsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dem file.
         * @param {DEMFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async demsUpdate(id: number, data: DEMFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DEMFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.demsUpdate(id, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DemsApi.demsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async demsUploadDem(name: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DEMFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.demsUploadDem(name, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DemsApi.demsUploadDem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DemsApi - factory interface
 * @export
 */
export const DemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DemsApiFp(configuration)
    return {
        /**
         * 
         * @param {DEMFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demsCreate(data: DEMFile, options?: any): AxiosPromise<DEMFile> {
            return localVarFp.demsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dem file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.demsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dem file.
         * @param {string} z 
         * @param {string} x 
         * @param {string} y 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demsGetTile(id: number, z: string, x: string, y: string, options?: any): AxiosPromise<DEMFile> {
            return localVarFp.demsGetTile(id, z, x, y, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demsList(options?: any): AxiosPromise<Array<DEMFile>> {
            return localVarFp.demsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dem file.
         * @param {DEMFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demsPartialUpdate(id: number, data: DEMFile, options?: any): AxiosPromise<DEMFile> {
            return localVarFp.demsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dem file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demsRead(id: number, options?: any): AxiosPromise<DEMFile> {
            return localVarFp.demsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this dem file.
         * @param {DEMFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demsUpdate(id: number, data: DEMFile, options?: any): AxiosPromise<DEMFile> {
            return localVarFp.demsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demsUploadDem(name: string, file: File, options?: any): AxiosPromise<DEMFile> {
            return localVarFp.demsUploadDem(name, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DemsApi - object-oriented interface
 * @export
 * @class DemsApi
 * @extends {BaseAPI}
 */
export class DemsApi extends BaseAPI {
    /**
     * 
     * @param {DEMFile} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemsApi
     */
    public demsCreate(data: DEMFile, options?: RawAxiosRequestConfig) {
        return DemsApiFp(this.configuration).demsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this dem file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemsApi
     */
    public demsDelete(id: number, options?: RawAxiosRequestConfig) {
        return DemsApiFp(this.configuration).demsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this dem file.
     * @param {string} z 
     * @param {string} x 
     * @param {string} y 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemsApi
     */
    public demsGetTile(id: number, z: string, x: string, y: string, options?: RawAxiosRequestConfig) {
        return DemsApiFp(this.configuration).demsGetTile(id, z, x, y, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemsApi
     */
    public demsList(options?: RawAxiosRequestConfig) {
        return DemsApiFp(this.configuration).demsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this dem file.
     * @param {DEMFile} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemsApi
     */
    public demsPartialUpdate(id: number, data: DEMFile, options?: RawAxiosRequestConfig) {
        return DemsApiFp(this.configuration).demsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this dem file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemsApi
     */
    public demsRead(id: number, options?: RawAxiosRequestConfig) {
        return DemsApiFp(this.configuration).demsRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this dem file.
     * @param {DEMFile} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemsApi
     */
    public demsUpdate(id: number, data: DEMFile, options?: RawAxiosRequestConfig) {
        return DemsApiFp(this.configuration).demsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemsApi
     */
    public demsUploadDem(name: string, file: File, options?: RawAxiosRequestConfig) {
        return DemsApiFp(this.configuration).demsUploadDem(name, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GeotiffsApi - axios parameter creator
 * @export
 */
export const GeotiffsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GeoTIFFFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geotiffsCreate: async (data: GeoTIFFFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('geotiffsCreate', 'data', data)
            const localVarPath = `/geotiffs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this geo tiff file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geotiffsDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('geotiffsDelete', 'id', id)
            const localVarPath = `/geotiffs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this geo tiff file.
         * @param {string} z 
         * @param {string} x 
         * @param {string} y 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geotiffsGetTile: async (id: number, z: string, x: string, y: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('geotiffsGetTile', 'id', id)
            // verify required parameter 'z' is not null or undefined
            assertParamExists('geotiffsGetTile', 'z', z)
            // verify required parameter 'x' is not null or undefined
            assertParamExists('geotiffsGetTile', 'x', x)
            // verify required parameter 'y' is not null or undefined
            assertParamExists('geotiffsGetTile', 'y', y)
            const localVarPath = `/geotiffs/{id}/tiles/{z}/{x}/{y}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"z"}}`, encodeURIComponent(String(z)))
                .replace(`{${"x"}}`, encodeURIComponent(String(x)))
                .replace(`{${"y"}}`, encodeURIComponent(String(y)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geotiffsList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/geotiffs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this geo tiff file.
         * @param {GeoTIFFFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geotiffsPartialUpdate: async (id: number, data: GeoTIFFFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('geotiffsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('geotiffsPartialUpdate', 'data', data)
            const localVarPath = `/geotiffs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this geo tiff file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geotiffsRead: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('geotiffsRead', 'id', id)
            const localVarPath = `/geotiffs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this geo tiff file.
         * @param {GeoTIFFFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geotiffsUpdate: async (id: number, data: GeoTIFFFile, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('geotiffsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('geotiffsUpdate', 'data', data)
            const localVarPath = `/geotiffs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geotiffsUploadGeotiff: async (name: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('geotiffsUploadGeotiff', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('geotiffsUploadGeotiff', 'file', file)
            const localVarPath = `/geotiffs/upload/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeotiffsApi - functional programming interface
 * @export
 */
export const GeotiffsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GeotiffsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {GeoTIFFFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geotiffsCreate(data: GeoTIFFFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeoTIFFFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geotiffsCreate(data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeotiffsApi.geotiffsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this geo tiff file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geotiffsDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geotiffsDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeotiffsApi.geotiffsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this geo tiff file.
         * @param {string} z 
         * @param {string} x 
         * @param {string} y 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geotiffsGetTile(id: number, z: string, x: string, y: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeoTIFFFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geotiffsGetTile(id, z, x, y, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeotiffsApi.geotiffsGetTile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geotiffsList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeoTIFFFile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geotiffsList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeotiffsApi.geotiffsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this geo tiff file.
         * @param {GeoTIFFFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geotiffsPartialUpdate(id: number, data: GeoTIFFFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeoTIFFFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geotiffsPartialUpdate(id, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeotiffsApi.geotiffsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this geo tiff file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geotiffsRead(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeoTIFFFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geotiffsRead(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeotiffsApi.geotiffsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this geo tiff file.
         * @param {GeoTIFFFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geotiffsUpdate(id: number, data: GeoTIFFFile, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeoTIFFFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geotiffsUpdate(id, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeotiffsApi.geotiffsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async geotiffsUploadGeotiff(name: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeoTIFFFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.geotiffsUploadGeotiff(name, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeotiffsApi.geotiffsUploadGeotiff']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GeotiffsApi - factory interface
 * @export
 */
export const GeotiffsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GeotiffsApiFp(configuration)
    return {
        /**
         * 
         * @param {GeoTIFFFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geotiffsCreate(data: GeoTIFFFile, options?: any): AxiosPromise<GeoTIFFFile> {
            return localVarFp.geotiffsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this geo tiff file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geotiffsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.geotiffsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this geo tiff file.
         * @param {string} z 
         * @param {string} x 
         * @param {string} y 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geotiffsGetTile(id: number, z: string, x: string, y: string, options?: any): AxiosPromise<GeoTIFFFile> {
            return localVarFp.geotiffsGetTile(id, z, x, y, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geotiffsList(options?: any): AxiosPromise<Array<GeoTIFFFile>> {
            return localVarFp.geotiffsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this geo tiff file.
         * @param {GeoTIFFFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geotiffsPartialUpdate(id: number, data: GeoTIFFFile, options?: any): AxiosPromise<GeoTIFFFile> {
            return localVarFp.geotiffsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this geo tiff file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geotiffsRead(id: number, options?: any): AxiosPromise<GeoTIFFFile> {
            return localVarFp.geotiffsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this geo tiff file.
         * @param {GeoTIFFFile} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geotiffsUpdate(id: number, data: GeoTIFFFile, options?: any): AxiosPromise<GeoTIFFFile> {
            return localVarFp.geotiffsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        geotiffsUploadGeotiff(name: string, file: File, options?: any): AxiosPromise<GeoTIFFFile> {
            return localVarFp.geotiffsUploadGeotiff(name, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GeotiffsApi - object-oriented interface
 * @export
 * @class GeotiffsApi
 * @extends {BaseAPI}
 */
export class GeotiffsApi extends BaseAPI {
    /**
     * 
     * @param {GeoTIFFFile} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeotiffsApi
     */
    public geotiffsCreate(data: GeoTIFFFile, options?: RawAxiosRequestConfig) {
        return GeotiffsApiFp(this.configuration).geotiffsCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this geo tiff file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeotiffsApi
     */
    public geotiffsDelete(id: number, options?: RawAxiosRequestConfig) {
        return GeotiffsApiFp(this.configuration).geotiffsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this geo tiff file.
     * @param {string} z 
     * @param {string} x 
     * @param {string} y 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeotiffsApi
     */
    public geotiffsGetTile(id: number, z: string, x: string, y: string, options?: RawAxiosRequestConfig) {
        return GeotiffsApiFp(this.configuration).geotiffsGetTile(id, z, x, y, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeotiffsApi
     */
    public geotiffsList(options?: RawAxiosRequestConfig) {
        return GeotiffsApiFp(this.configuration).geotiffsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this geo tiff file.
     * @param {GeoTIFFFile} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeotiffsApi
     */
    public geotiffsPartialUpdate(id: number, data: GeoTIFFFile, options?: RawAxiosRequestConfig) {
        return GeotiffsApiFp(this.configuration).geotiffsPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this geo tiff file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeotiffsApi
     */
    public geotiffsRead(id: number, options?: RawAxiosRequestConfig) {
        return GeotiffsApiFp(this.configuration).geotiffsRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this geo tiff file.
     * @param {GeoTIFFFile} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeotiffsApi
     */
    public geotiffsUpdate(id: number, data: GeoTIFFFile, options?: RawAxiosRequestConfig) {
        return GeotiffsApiFp(this.configuration).geotiffsUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeotiffsApi
     */
    public geotiffsUploadGeotiff(name: string, file: File, options?: RawAxiosRequestConfig) {
        return GeotiffsApiFp(this.configuration).geotiffsUploadGeotiff(name, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GlbmeshesApi - axios parameter creator
 * @export
 */
export const GlbmeshesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this GLB Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glbmeshesContent: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('glbmeshesContent', 'id', id)
            const localVarPath = `/glbmeshes/{id}/content/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GLBMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glbmeshesCreate: async (data: GLBMesh, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('glbmeshesCreate', 'data', data)
            const localVarPath = `/glbmeshes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this GLB Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glbmeshesDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('glbmeshesDelete', 'id', id)
            const localVarPath = `/glbmeshes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this GLB Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glbmeshesGetJson: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('glbmeshesGetJson', 'id', id)
            const localVarPath = `/glbmeshes/{id}/get_json/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glbmeshesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/glbmeshes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this GLB Mesh.
         * @param {GLBMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glbmeshesPartialUpdate: async (id: number, data: GLBMesh, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('glbmeshesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('glbmeshesPartialUpdate', 'data', data)
            const localVarPath = `/glbmeshes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this GLB Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glbmeshesRead: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('glbmeshesRead', 'id', id)
            const localVarPath = `/glbmeshes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this GLB Mesh.
         * @param {GLBMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glbmeshesUpdate: async (id: number, data: GLBMesh, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('glbmeshesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('glbmeshesUpdate', 'data', data)
            const localVarPath = `/glbmeshes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {File} file 
         * @param {File | null} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glbmeshesUploadMesh: async (name: string, file: File, data?: File | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('glbmeshesUploadMesh', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('glbmeshesUploadMesh', 'file', file)
            const localVarPath = `/glbmeshes/upload/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GlbmeshesApi - functional programming interface
 * @export
 */
export const GlbmeshesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GlbmeshesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this GLB Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glbmeshesContent(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GLBMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glbmeshesContent(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlbmeshesApi.glbmeshesContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GLBMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glbmeshesCreate(data: GLBMesh, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GLBMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glbmeshesCreate(data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlbmeshesApi.glbmeshesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this GLB Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glbmeshesDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glbmeshesDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlbmeshesApi.glbmeshesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this GLB Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glbmeshesGetJson(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GLBMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glbmeshesGetJson(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlbmeshesApi.glbmeshesGetJson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glbmeshesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GLBMesh>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glbmeshesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlbmeshesApi.glbmeshesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this GLB Mesh.
         * @param {GLBMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glbmeshesPartialUpdate(id: number, data: GLBMesh, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GLBMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glbmeshesPartialUpdate(id, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlbmeshesApi.glbmeshesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this GLB Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glbmeshesRead(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GLBMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glbmeshesRead(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlbmeshesApi.glbmeshesRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this GLB Mesh.
         * @param {GLBMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glbmeshesUpdate(id: number, data: GLBMesh, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GLBMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glbmeshesUpdate(id, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlbmeshesApi.glbmeshesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {File} file 
         * @param {File | null} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async glbmeshesUploadMesh(name: string, file: File, data?: File | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GLBMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.glbmeshesUploadMesh(name, file, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GlbmeshesApi.glbmeshesUploadMesh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GlbmeshesApi - factory interface
 * @export
 */
export const GlbmeshesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GlbmeshesApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this GLB Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glbmeshesContent(id: number, options?: any): AxiosPromise<GLBMesh> {
            return localVarFp.glbmeshesContent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GLBMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glbmeshesCreate(data: GLBMesh, options?: any): AxiosPromise<GLBMesh> {
            return localVarFp.glbmeshesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this GLB Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glbmeshesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.glbmeshesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this GLB Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glbmeshesGetJson(id: number, options?: any): AxiosPromise<GLBMesh> {
            return localVarFp.glbmeshesGetJson(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glbmeshesList(options?: any): AxiosPromise<Array<GLBMesh>> {
            return localVarFp.glbmeshesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this GLB Mesh.
         * @param {GLBMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glbmeshesPartialUpdate(id: number, data: GLBMesh, options?: any): AxiosPromise<GLBMesh> {
            return localVarFp.glbmeshesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this GLB Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glbmeshesRead(id: number, options?: any): AxiosPromise<GLBMesh> {
            return localVarFp.glbmeshesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this GLB Mesh.
         * @param {GLBMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glbmeshesUpdate(id: number, data: GLBMesh, options?: any): AxiosPromise<GLBMesh> {
            return localVarFp.glbmeshesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {File} file 
         * @param {File | null} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        glbmeshesUploadMesh(name: string, file: File, data?: File | null, options?: any): AxiosPromise<GLBMesh> {
            return localVarFp.glbmeshesUploadMesh(name, file, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GlbmeshesApi - object-oriented interface
 * @export
 * @class GlbmeshesApi
 * @extends {BaseAPI}
 */
export class GlbmeshesApi extends BaseAPI {
    /**
     * 
     * @param {number} id A unique integer value identifying this GLB Mesh.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlbmeshesApi
     */
    public glbmeshesContent(id: number, options?: RawAxiosRequestConfig) {
        return GlbmeshesApiFp(this.configuration).glbmeshesContent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GLBMesh} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlbmeshesApi
     */
    public glbmeshesCreate(data: GLBMesh, options?: RawAxiosRequestConfig) {
        return GlbmeshesApiFp(this.configuration).glbmeshesCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this GLB Mesh.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlbmeshesApi
     */
    public glbmeshesDelete(id: number, options?: RawAxiosRequestConfig) {
        return GlbmeshesApiFp(this.configuration).glbmeshesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this GLB Mesh.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlbmeshesApi
     */
    public glbmeshesGetJson(id: number, options?: RawAxiosRequestConfig) {
        return GlbmeshesApiFp(this.configuration).glbmeshesGetJson(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlbmeshesApi
     */
    public glbmeshesList(options?: RawAxiosRequestConfig) {
        return GlbmeshesApiFp(this.configuration).glbmeshesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this GLB Mesh.
     * @param {GLBMesh} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlbmeshesApi
     */
    public glbmeshesPartialUpdate(id: number, data: GLBMesh, options?: RawAxiosRequestConfig) {
        return GlbmeshesApiFp(this.configuration).glbmeshesPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this GLB Mesh.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlbmeshesApi
     */
    public glbmeshesRead(id: number, options?: RawAxiosRequestConfig) {
        return GlbmeshesApiFp(this.configuration).glbmeshesRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this GLB Mesh.
     * @param {GLBMesh} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlbmeshesApi
     */
    public glbmeshesUpdate(id: number, data: GLBMesh, options?: RawAxiosRequestConfig) {
        return GlbmeshesApiFp(this.configuration).glbmeshesUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {File} file 
     * @param {File | null} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GlbmeshesApi
     */
    public glbmeshesUploadMesh(name: string, file: File, data?: File | null, options?: RawAxiosRequestConfig) {
        return GlbmeshesApiFp(this.configuration).glbmeshesUploadMesh(name, file, data, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ObjmeshesApi - axios parameter creator
 * @export
 */
export const ObjmeshesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this OBJ Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objmeshesContent: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('objmeshesContent', 'id', id)
            const localVarPath = `/objmeshes/{id}/content/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OBJMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objmeshesCreate: async (data: OBJMesh, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('objmeshesCreate', 'data', data)
            const localVarPath = `/objmeshes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this OBJ Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objmeshesDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('objmeshesDelete', 'id', id)
            const localVarPath = `/objmeshes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this OBJ Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objmeshesGetJson: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('objmeshesGetJson', 'id', id)
            const localVarPath = `/objmeshes/{id}/get_json/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objmeshesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/objmeshes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this OBJ Mesh.
         * @param {OBJMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objmeshesPartialUpdate: async (id: number, data: OBJMesh, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('objmeshesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('objmeshesPartialUpdate', 'data', data)
            const localVarPath = `/objmeshes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this OBJ Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objmeshesRead: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('objmeshesRead', 'id', id)
            const localVarPath = `/objmeshes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this OBJ Mesh.
         * @param {OBJMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objmeshesUpdate: async (id: number, data: OBJMesh, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('objmeshesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('objmeshesUpdate', 'data', data)
            const localVarPath = `/objmeshes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {File} file 
         * @param {File | null} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objmeshesUploadMesh: async (name: string, file: File, data?: File | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('objmeshesUploadMesh', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('objmeshesUploadMesh', 'file', file)
            const localVarPath = `/objmeshes/upload/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjmeshesApi - functional programming interface
 * @export
 */
export const ObjmeshesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ObjmeshesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this OBJ Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async objmeshesContent(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OBJMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.objmeshesContent(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjmeshesApi.objmeshesContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {OBJMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async objmeshesCreate(data: OBJMesh, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OBJMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.objmeshesCreate(data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjmeshesApi.objmeshesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this OBJ Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async objmeshesDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.objmeshesDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjmeshesApi.objmeshesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this OBJ Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async objmeshesGetJson(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OBJMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.objmeshesGetJson(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjmeshesApi.objmeshesGetJson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async objmeshesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OBJMesh>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.objmeshesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjmeshesApi.objmeshesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this OBJ Mesh.
         * @param {OBJMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async objmeshesPartialUpdate(id: number, data: OBJMesh, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OBJMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.objmeshesPartialUpdate(id, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjmeshesApi.objmeshesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this OBJ Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async objmeshesRead(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OBJMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.objmeshesRead(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjmeshesApi.objmeshesRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this OBJ Mesh.
         * @param {OBJMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async objmeshesUpdate(id: number, data: OBJMesh, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OBJMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.objmeshesUpdate(id, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjmeshesApi.objmeshesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {File} file 
         * @param {File | null} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async objmeshesUploadMesh(name: string, file: File, data?: File | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OBJMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.objmeshesUploadMesh(name, file, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ObjmeshesApi.objmeshesUploadMesh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ObjmeshesApi - factory interface
 * @export
 */
export const ObjmeshesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ObjmeshesApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this OBJ Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objmeshesContent(id: number, options?: any): AxiosPromise<OBJMesh> {
            return localVarFp.objmeshesContent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OBJMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objmeshesCreate(data: OBJMesh, options?: any): AxiosPromise<OBJMesh> {
            return localVarFp.objmeshesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this OBJ Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objmeshesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.objmeshesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this OBJ Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objmeshesGetJson(id: number, options?: any): AxiosPromise<OBJMesh> {
            return localVarFp.objmeshesGetJson(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objmeshesList(options?: any): AxiosPromise<Array<OBJMesh>> {
            return localVarFp.objmeshesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this OBJ Mesh.
         * @param {OBJMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objmeshesPartialUpdate(id: number, data: OBJMesh, options?: any): AxiosPromise<OBJMesh> {
            return localVarFp.objmeshesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this OBJ Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objmeshesRead(id: number, options?: any): AxiosPromise<OBJMesh> {
            return localVarFp.objmeshesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this OBJ Mesh.
         * @param {OBJMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objmeshesUpdate(id: number, data: OBJMesh, options?: any): AxiosPromise<OBJMesh> {
            return localVarFp.objmeshesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {File} file 
         * @param {File | null} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objmeshesUploadMesh(name: string, file: File, data?: File | null, options?: any): AxiosPromise<OBJMesh> {
            return localVarFp.objmeshesUploadMesh(name, file, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ObjmeshesApi - object-oriented interface
 * @export
 * @class ObjmeshesApi
 * @extends {BaseAPI}
 */
export class ObjmeshesApi extends BaseAPI {
    /**
     * 
     * @param {number} id A unique integer value identifying this OBJ Mesh.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjmeshesApi
     */
    public objmeshesContent(id: number, options?: RawAxiosRequestConfig) {
        return ObjmeshesApiFp(this.configuration).objmeshesContent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OBJMesh} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjmeshesApi
     */
    public objmeshesCreate(data: OBJMesh, options?: RawAxiosRequestConfig) {
        return ObjmeshesApiFp(this.configuration).objmeshesCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this OBJ Mesh.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjmeshesApi
     */
    public objmeshesDelete(id: number, options?: RawAxiosRequestConfig) {
        return ObjmeshesApiFp(this.configuration).objmeshesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this OBJ Mesh.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjmeshesApi
     */
    public objmeshesGetJson(id: number, options?: RawAxiosRequestConfig) {
        return ObjmeshesApiFp(this.configuration).objmeshesGetJson(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjmeshesApi
     */
    public objmeshesList(options?: RawAxiosRequestConfig) {
        return ObjmeshesApiFp(this.configuration).objmeshesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this OBJ Mesh.
     * @param {OBJMesh} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjmeshesApi
     */
    public objmeshesPartialUpdate(id: number, data: OBJMesh, options?: RawAxiosRequestConfig) {
        return ObjmeshesApiFp(this.configuration).objmeshesPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this OBJ Mesh.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjmeshesApi
     */
    public objmeshesRead(id: number, options?: RawAxiosRequestConfig) {
        return ObjmeshesApiFp(this.configuration).objmeshesRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this OBJ Mesh.
     * @param {OBJMesh} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjmeshesApi
     */
    public objmeshesUpdate(id: number, data: OBJMesh, options?: RawAxiosRequestConfig) {
        return ObjmeshesApiFp(this.configuration).objmeshesUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {File} file 
     * @param {File | null} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjmeshesApi
     */
    public objmeshesUploadMesh(name: string, file: File, data?: File | null, options?: RawAxiosRequestConfig) {
        return ObjmeshesApiFp(this.configuration).objmeshesUploadMesh(name, file, data, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlymeshesApi - axios parameter creator
 * @export
 */
export const PlymeshesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this PLY Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plymeshesContent: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('plymeshesContent', 'id', id)
            const localVarPath = `/plymeshes/{id}/content/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PLYMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plymeshesCreate: async (data: PLYMesh, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('plymeshesCreate', 'data', data)
            const localVarPath = `/plymeshes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this PLY Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plymeshesDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('plymeshesDelete', 'id', id)
            const localVarPath = `/plymeshes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this PLY Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plymeshesGetJson: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('plymeshesGetJson', 'id', id)
            const localVarPath = `/plymeshes/{id}/get_json/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plymeshesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/plymeshes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this PLY Mesh.
         * @param {PLYMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plymeshesPartialUpdate: async (id: number, data: PLYMesh, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('plymeshesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('plymeshesPartialUpdate', 'data', data)
            const localVarPath = `/plymeshes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this PLY Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plymeshesRead: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('plymeshesRead', 'id', id)
            const localVarPath = `/plymeshes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this PLY Mesh.
         * @param {PLYMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plymeshesUpdate: async (id: number, data: PLYMesh, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('plymeshesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('plymeshesUpdate', 'data', data)
            const localVarPath = `/plymeshes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {File} file 
         * @param {File | null} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plymeshesUploadMesh: async (name: string, file: File, data?: File | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('plymeshesUploadMesh', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('plymeshesUploadMesh', 'file', file)
            const localVarPath = `/plymeshes/upload/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlymeshesApi - functional programming interface
 * @export
 */
export const PlymeshesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlymeshesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this PLY Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async plymeshesContent(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PLYMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.plymeshesContent(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlymeshesApi.plymeshesContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PLYMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async plymeshesCreate(data: PLYMesh, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PLYMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.plymeshesCreate(data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlymeshesApi.plymeshesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this PLY Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async plymeshesDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.plymeshesDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlymeshesApi.plymeshesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this PLY Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async plymeshesGetJson(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PLYMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.plymeshesGetJson(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlymeshesApi.plymeshesGetJson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async plymeshesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PLYMesh>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.plymeshesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlymeshesApi.plymeshesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this PLY Mesh.
         * @param {PLYMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async plymeshesPartialUpdate(id: number, data: PLYMesh, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PLYMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.plymeshesPartialUpdate(id, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlymeshesApi.plymeshesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this PLY Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async plymeshesRead(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PLYMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.plymeshesRead(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlymeshesApi.plymeshesRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this PLY Mesh.
         * @param {PLYMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async plymeshesUpdate(id: number, data: PLYMesh, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PLYMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.plymeshesUpdate(id, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlymeshesApi.plymeshesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {File} file 
         * @param {File | null} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async plymeshesUploadMesh(name: string, file: File, data?: File | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PLYMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.plymeshesUploadMesh(name, file, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlymeshesApi.plymeshesUploadMesh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlymeshesApi - factory interface
 * @export
 */
export const PlymeshesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlymeshesApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this PLY Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plymeshesContent(id: number, options?: any): AxiosPromise<PLYMesh> {
            return localVarFp.plymeshesContent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PLYMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plymeshesCreate(data: PLYMesh, options?: any): AxiosPromise<PLYMesh> {
            return localVarFp.plymeshesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this PLY Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plymeshesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.plymeshesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this PLY Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plymeshesGetJson(id: number, options?: any): AxiosPromise<PLYMesh> {
            return localVarFp.plymeshesGetJson(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plymeshesList(options?: any): AxiosPromise<Array<PLYMesh>> {
            return localVarFp.plymeshesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this PLY Mesh.
         * @param {PLYMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plymeshesPartialUpdate(id: number, data: PLYMesh, options?: any): AxiosPromise<PLYMesh> {
            return localVarFp.plymeshesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this PLY Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plymeshesRead(id: number, options?: any): AxiosPromise<PLYMesh> {
            return localVarFp.plymeshesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this PLY Mesh.
         * @param {PLYMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plymeshesUpdate(id: number, data: PLYMesh, options?: any): AxiosPromise<PLYMesh> {
            return localVarFp.plymeshesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {File} file 
         * @param {File | null} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        plymeshesUploadMesh(name: string, file: File, data?: File | null, options?: any): AxiosPromise<PLYMesh> {
            return localVarFp.plymeshesUploadMesh(name, file, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlymeshesApi - object-oriented interface
 * @export
 * @class PlymeshesApi
 * @extends {BaseAPI}
 */
export class PlymeshesApi extends BaseAPI {
    /**
     * 
     * @param {number} id A unique integer value identifying this PLY Mesh.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlymeshesApi
     */
    public plymeshesContent(id: number, options?: RawAxiosRequestConfig) {
        return PlymeshesApiFp(this.configuration).plymeshesContent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PLYMesh} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlymeshesApi
     */
    public plymeshesCreate(data: PLYMesh, options?: RawAxiosRequestConfig) {
        return PlymeshesApiFp(this.configuration).plymeshesCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this PLY Mesh.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlymeshesApi
     */
    public plymeshesDelete(id: number, options?: RawAxiosRequestConfig) {
        return PlymeshesApiFp(this.configuration).plymeshesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this PLY Mesh.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlymeshesApi
     */
    public plymeshesGetJson(id: number, options?: RawAxiosRequestConfig) {
        return PlymeshesApiFp(this.configuration).plymeshesGetJson(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlymeshesApi
     */
    public plymeshesList(options?: RawAxiosRequestConfig) {
        return PlymeshesApiFp(this.configuration).plymeshesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this PLY Mesh.
     * @param {PLYMesh} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlymeshesApi
     */
    public plymeshesPartialUpdate(id: number, data: PLYMesh, options?: RawAxiosRequestConfig) {
        return PlymeshesApiFp(this.configuration).plymeshesPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this PLY Mesh.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlymeshesApi
     */
    public plymeshesRead(id: number, options?: RawAxiosRequestConfig) {
        return PlymeshesApiFp(this.configuration).plymeshesRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this PLY Mesh.
     * @param {PLYMesh} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlymeshesApi
     */
    public plymeshesUpdate(id: number, data: PLYMesh, options?: RawAxiosRequestConfig) {
        return PlymeshesApiFp(this.configuration).plymeshesUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {File} file 
     * @param {File | null} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlymeshesApi
     */
    public plymeshesUploadMesh(name: string, file: File, data?: File | null, options?: RawAxiosRequestConfig) {
        return PlymeshesApiFp(this.configuration).plymeshesUploadMesh(name, file, data, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PointcloudmeshesApi - axios parameter creator
 * @export
 */
export const PointcloudmeshesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this Point Cloud Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointcloudmeshesContent: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pointcloudmeshesContent', 'id', id)
            const localVarPath = `/pointcloudmeshes/{id}/content/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PointCloudMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointcloudmeshesCreate: async (data: PointCloudMesh, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('pointcloudmeshesCreate', 'data', data)
            const localVarPath = `/pointcloudmeshes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Point Cloud Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointcloudmeshesDelete: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pointcloudmeshesDelete', 'id', id)
            const localVarPath = `/pointcloudmeshes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Point Cloud Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointcloudmeshesGetJson: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pointcloudmeshesGetJson', 'id', id)
            const localVarPath = `/pointcloudmeshes/{id}/get_json/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointcloudmeshesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pointcloudmeshes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Point Cloud Mesh.
         * @param {PointCloudMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointcloudmeshesPartialUpdate: async (id: number, data: PointCloudMesh, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pointcloudmeshesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('pointcloudmeshesPartialUpdate', 'data', data)
            const localVarPath = `/pointcloudmeshes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Point Cloud Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointcloudmeshesRead: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pointcloudmeshesRead', 'id', id)
            const localVarPath = `/pointcloudmeshes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Point Cloud Mesh.
         * @param {PointCloudMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointcloudmeshesUpdate: async (id: number, data: PointCloudMesh, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pointcloudmeshesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('pointcloudmeshesUpdate', 'data', data)
            const localVarPath = `/pointcloudmeshes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {File} file 
         * @param {File | null} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointcloudmeshesUploadMesh: async (name: string, file: File, data?: File | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('pointcloudmeshesUploadMesh', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('pointcloudmeshesUploadMesh', 'file', file)
            const localVarPath = `/pointcloudmeshes/upload/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (data !== undefined) { 
                localVarFormParams.append('data', data as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PointcloudmeshesApi - functional programming interface
 * @export
 */
export const PointcloudmeshesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PointcloudmeshesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this Point Cloud Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointcloudmeshesContent(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointCloudMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointcloudmeshesContent(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PointcloudmeshesApi.pointcloudmeshesContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PointCloudMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointcloudmeshesCreate(data: PointCloudMesh, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointCloudMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointcloudmeshesCreate(data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PointcloudmeshesApi.pointcloudmeshesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Point Cloud Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointcloudmeshesDelete(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointcloudmeshesDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PointcloudmeshesApi.pointcloudmeshesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Point Cloud Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointcloudmeshesGetJson(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointCloudMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointcloudmeshesGetJson(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PointcloudmeshesApi.pointcloudmeshesGetJson']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointcloudmeshesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PointCloudMesh>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointcloudmeshesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PointcloudmeshesApi.pointcloudmeshesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Point Cloud Mesh.
         * @param {PointCloudMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointcloudmeshesPartialUpdate(id: number, data: PointCloudMesh, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointCloudMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointcloudmeshesPartialUpdate(id, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PointcloudmeshesApi.pointcloudmeshesPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Point Cloud Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointcloudmeshesRead(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointCloudMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointcloudmeshesRead(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PointcloudmeshesApi.pointcloudmeshesRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Point Cloud Mesh.
         * @param {PointCloudMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointcloudmeshesUpdate(id: number, data: PointCloudMesh, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointCloudMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointcloudmeshesUpdate(id, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PointcloudmeshesApi.pointcloudmeshesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} name 
         * @param {File} file 
         * @param {File | null} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pointcloudmeshesUploadMesh(name: string, file: File, data?: File | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PointCloudMesh>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pointcloudmeshesUploadMesh(name, file, data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PointcloudmeshesApi.pointcloudmeshesUploadMesh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PointcloudmeshesApi - factory interface
 * @export
 */
export const PointcloudmeshesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PointcloudmeshesApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id A unique integer value identifying this Point Cloud Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointcloudmeshesContent(id: number, options?: any): AxiosPromise<PointCloudMesh> {
            return localVarFp.pointcloudmeshesContent(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PointCloudMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointcloudmeshesCreate(data: PointCloudMesh, options?: any): AxiosPromise<PointCloudMesh> {
            return localVarFp.pointcloudmeshesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Point Cloud Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointcloudmeshesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.pointcloudmeshesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Point Cloud Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointcloudmeshesGetJson(id: number, options?: any): AxiosPromise<PointCloudMesh> {
            return localVarFp.pointcloudmeshesGetJson(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointcloudmeshesList(options?: any): AxiosPromise<Array<PointCloudMesh>> {
            return localVarFp.pointcloudmeshesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Point Cloud Mesh.
         * @param {PointCloudMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointcloudmeshesPartialUpdate(id: number, data: PointCloudMesh, options?: any): AxiosPromise<PointCloudMesh> {
            return localVarFp.pointcloudmeshesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Point Cloud Mesh.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointcloudmeshesRead(id: number, options?: any): AxiosPromise<PointCloudMesh> {
            return localVarFp.pointcloudmeshesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this Point Cloud Mesh.
         * @param {PointCloudMesh} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointcloudmeshesUpdate(id: number, data: PointCloudMesh, options?: any): AxiosPromise<PointCloudMesh> {
            return localVarFp.pointcloudmeshesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {File} file 
         * @param {File | null} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pointcloudmeshesUploadMesh(name: string, file: File, data?: File | null, options?: any): AxiosPromise<PointCloudMesh> {
            return localVarFp.pointcloudmeshesUploadMesh(name, file, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PointcloudmeshesApi - object-oriented interface
 * @export
 * @class PointcloudmeshesApi
 * @extends {BaseAPI}
 */
export class PointcloudmeshesApi extends BaseAPI {
    /**
     * 
     * @param {number} id A unique integer value identifying this Point Cloud Mesh.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointcloudmeshesApi
     */
    public pointcloudmeshesContent(id: number, options?: RawAxiosRequestConfig) {
        return PointcloudmeshesApiFp(this.configuration).pointcloudmeshesContent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PointCloudMesh} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointcloudmeshesApi
     */
    public pointcloudmeshesCreate(data: PointCloudMesh, options?: RawAxiosRequestConfig) {
        return PointcloudmeshesApiFp(this.configuration).pointcloudmeshesCreate(data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Point Cloud Mesh.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointcloudmeshesApi
     */
    public pointcloudmeshesDelete(id: number, options?: RawAxiosRequestConfig) {
        return PointcloudmeshesApiFp(this.configuration).pointcloudmeshesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Point Cloud Mesh.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointcloudmeshesApi
     */
    public pointcloudmeshesGetJson(id: number, options?: RawAxiosRequestConfig) {
        return PointcloudmeshesApiFp(this.configuration).pointcloudmeshesGetJson(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointcloudmeshesApi
     */
    public pointcloudmeshesList(options?: RawAxiosRequestConfig) {
        return PointcloudmeshesApiFp(this.configuration).pointcloudmeshesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Point Cloud Mesh.
     * @param {PointCloudMesh} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointcloudmeshesApi
     */
    public pointcloudmeshesPartialUpdate(id: number, data: PointCloudMesh, options?: RawAxiosRequestConfig) {
        return PointcloudmeshesApiFp(this.configuration).pointcloudmeshesPartialUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Point Cloud Mesh.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointcloudmeshesApi
     */
    public pointcloudmeshesRead(id: number, options?: RawAxiosRequestConfig) {
        return PointcloudmeshesApiFp(this.configuration).pointcloudmeshesRead(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this Point Cloud Mesh.
     * @param {PointCloudMesh} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointcloudmeshesApi
     */
    public pointcloudmeshesUpdate(id: number, data: PointCloudMesh, options?: RawAxiosRequestConfig) {
        return PointcloudmeshesApiFp(this.configuration).pointcloudmeshesUpdate(id, data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {File} file 
     * @param {File | null} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PointcloudmeshesApi
     */
    public pointcloudmeshesUploadMesh(name: string, file: File, data?: File | null, options?: RawAxiosRequestConfig) {
        return PointcloudmeshesApiFp(this.configuration).pointcloudmeshesUploadMesh(name, file, data, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VolumeApi - axios parameter creator
 * @export
 */
export const VolumeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Polygon} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumeComputation: async (data: Polygon, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('volumeComputation', 'data', data)
            const localVarPath = `/volume/computation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VolumeApi - functional programming interface
 * @export
 */
export const VolumeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VolumeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Polygon} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async volumeComputation(data: Polygon, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.volumeComputation(data, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VolumeApi.volumeComputation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VolumeApi - factory interface
 * @export
 */
export const VolumeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VolumeApiFp(configuration)
    return {
        /**
         * 
         * @param {Polygon} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumeComputation(data: Polygon, options?: any): AxiosPromise<void> {
            return localVarFp.volumeComputation(data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VolumeApi - object-oriented interface
 * @export
 * @class VolumeApi
 * @extends {BaseAPI}
 */
export class VolumeApi extends BaseAPI {
    /**
     * 
     * @param {Polygon} data 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VolumeApi
     */
    public volumeComputation(data: Polygon, options?: RawAxiosRequestConfig) {
        return VolumeApiFp(this.configuration).volumeComputation(data, options).then((request) => request(this.axios, this.basePath));
    }
}



